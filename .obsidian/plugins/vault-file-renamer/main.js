/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultFileRenamerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// folder-suggest.ts
var import_obsidian = require("obsidian");
var FolderSuggest = class extends import_obsidian.AbstractInputSuggest {
  constructor(app, inputEl, onSelect) {
    super(app, inputEl);
    const vaultFolders = app.vault.getAllFolders(true).map((f) => f.path);
    this.folders = Array.from(new Set(["/"].concat(vaultFolders)));
    this.onSelectCb = onSelect;
  }
  getSuggestions(inputStr) {
    const q = (inputStr || "").toLowerCase();
    return this.folders.filter((f) => f.toLowerCase().includes(q));
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value });
  }
  selectSuggestion(value) {
    if (this.onSelectCb) {
      this.onSelectCb(value);
      this.close();
      return;
    }
    this.inputEl.value = value;
    const ev = new Event("input");
    this.inputEl.dispatchEvent(ev);
    this.close();
  }
};

// file-suggest.ts
var import_obsidian2 = require("obsidian");
var FileSuggest = class extends import_obsidian2.AbstractInputSuggest {
  constructor(app, inputEl, onSelect) {
    super(app, inputEl);
    this.files = app.vault.getFiles().map((f) => f.path);
    this.onSelectCb = onSelect;
  }
  getSuggestions(inputStr) {
    const q = (inputStr || "").toLowerCase();
    return this.files.filter((f) => f.toLowerCase().includes(q));
  }
  renderSuggestion(value, el) {
    el.createEl("div", { text: value });
  }
  selectSuggestion(value) {
    if (this.onSelectCb) {
      this.onSelectCb(value);
      this.close();
      return;
    }
    this.inputEl.value = value;
    const ev = new Event("input");
    this.inputEl.dispatchEvent(ev);
    this.close();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enabled: false,
  // Safer default: only .md. Users can expand this list.
  targetExtensions: ["md"],
  // When targetExtensions is empty (i.e., all), exclude none by default.
  excludedExtensions: [],
  // Avoid touching Obsidian internals by default.
  blacklistedFolders: [".obsidian"],
  // No file-level blacklist by default.
  blacklistedFiles: []
};
var VaultFileRenamerPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.renamingInProgress = /* @__PURE__ */ new Set();
  }
  async onload() {
    await this.loadSettings();
    this.registerEvent(
      this.app.vault.on("create", async (item) => {
        if (!this.settings.enabled)
          return;
        if (item instanceof import_obsidian3.TFile) {
          setTimeout(() => this.standardizeFile(item), 50);
        } else if (item instanceof import_obsidian3.TFolder) {
          setTimeout(() => this.standardizeFolder(item), 50);
        }
      })
    );
    this.registerEvent(
      this.app.vault.on("rename", async (item) => {
        if (!this.settings.enabled)
          return;
        if (item instanceof import_obsidian3.TFile) {
          setTimeout(() => this.standardizeFile(item), 50);
        } else if (item instanceof import_obsidian3.TFolder) {
          setTimeout(() => this.standardizeFolder(item), 50);
        }
      })
    );
    this.addCommand({
      id: "vfr-standardize-all-now",
      name: "Standardize everything now",
      callback: async () => {
        await this.standardizeAll();
        new import_obsidian3.Notice("Vault File Renamer: sweep completed.");
      }
    });
    const ribbonIconEl = this.addRibbonIcon(
      "dice",
      "Vault File Renamer",
      () => {
        new import_obsidian3.Notice(
          this.settings.enabled ? "Vault File Renamer is ACTIVE (auto-rename)." : "Vault File Renamer is DISABLED."
        );
      }
    );
    ribbonIconEl.addClass("vault-file-renamer-ribbon");
    this.addSettingTab(new VaultFileRenamerSettingTab(this.app, this));
  }
  onunload() {
  }
  /** Sweep the entire vault (respects blacklists and extensions). */
  async standardizeAll() {
    await this.standardizeAllFolders(this.app.vault.getRoot());
    const files = this.app.vault.getFiles();
    for (const file of files) {
      await this.standardizeFile(file);
    }
  }
  async standardizeAllFolders(folder) {
    for (const child of folder.children) {
      if (child instanceof import_obsidian3.TFolder) {
        await this.standardizeAllFolders(child);
        await this.standardizeFolder(child);
      }
    }
  }
  isUnderBlacklistedFolder(pathInVault) {
    const normalizedTarget = (0, import_obsidian3.normalizePath)(pathInVault);
    const blacklisted = this.settings.blacklistedFolders.map(
      (p) => (0, import_obsidian3.normalizePath)(p)
    );
    return blacklisted.some((blk) => {
      if (blk === "" || blk === "/")
        return false;
      return normalizedTarget === blk || normalizedTarget.startsWith(blk + "/");
    });
  }
  isBlacklistedFile(pathInVault) {
    const normalizedTarget = (0, import_obsidian3.normalizePath)(pathInVault);
    const files = this.settings.blacklistedFiles.map(
      (p) => (0, import_obsidian3.normalizePath)(p)
    );
    return files.includes(normalizedTarget);
  }
  /**
   * Decide whether a file extension is eligible for renaming.
   * Priority order:
   * 1) If extension is in excludedExtensions => NEVER rename (wins over allow-list).
   * 2) If targetExtensions (allow-list) is non-empty => only rename if included.
   * 3) If allow-list is empty => rename ALL except excluded (handled in #1).
   */
  isAllowedFileType(file) {
    const allowList = this.settings.targetExtensions.map((e) => e.trim().toLowerCase()).filter(Boolean);
    const excludeList = this.settings.excludedExtensions.map((e) => e.trim().toLowerCase()).filter(Boolean);
    const ext = (file.extension || "").toLowerCase();
    if (excludeList.includes(ext))
      return false;
    if (allowList.length > 0) {
      return allowList.includes(ext);
    }
    return true;
  }
  async standardizeFile(file) {
    if (this.renamingInProgress.has(file.path))
      return;
    if (this.isUnderBlacklistedFolder(file.path))
      return;
    if (this.isBlacklistedFile(file.path))
      return;
    if (!this.isAllowedFileType(file))
      return;
    const newBaseName = this.generateStandardName(file.name);
    const folderPath = file.parent ? file.parent.path : "";
    const newPath = (0, import_obsidian3.normalizePath)(
      folderPath ? `${folderPath}/${newBaseName}` : newBaseName
    );
    if (file.path === newPath)
      return;
    const existing = this.app.vault.getAbstractFileByPath(newPath);
    if (existing && existing !== file) {
      new import_obsidian3.Notice(
        `A file named "${newBaseName}" already exists. Skipping.`
      );
      return;
    }
    this.renamingInProgress.add(file.path);
    try {
      await this.app.vault.rename(file, newPath);
    } catch (error) {
      console.error(`Error renaming file ${file.path}:`, error);
    } finally {
      this.renamingInProgress.delete(file.path);
    }
  }
  async standardizeFolder(folder) {
    if (this.renamingInProgress.has(folder.path))
      return;
    if (this.isUnderBlacklistedFolder(folder.path))
      return;
    const newBaseName = this.generateStandardNameForFolder(folder.name);
    const parentPath = folder.parent ? folder.parent.path : "";
    const newPath = (0, import_obsidian3.normalizePath)(
      parentPath ? `${parentPath}/${newBaseName}` : newBaseName
    );
    if (folder.path === newPath)
      return;
    const existing = this.app.vault.getAbstractFileByPath(newPath);
    if (existing && existing !== folder) {
      new import_obsidian3.Notice(
        `A folder named "${newBaseName}" already exists. Skipping.`
      );
      return;
    }
    this.renamingInProgress.add(folder.path);
    try {
      await this.app.vault.rename(folder, newPath);
    } catch (error) {
      console.error(`Error renaming folder ${folder.path}:`, error);
    } finally {
      this.renamingInProgress.delete(folder.path);
    }
  }
  // Standardizes file names (keeps extension)
  generateStandardName(originalName) {
    const dotIndex = originalName.lastIndexOf(".");
    let base = originalName;
    let extension = "";
    if (dotIndex > 0) {
      base = originalName.substring(0, dotIndex);
      extension = originalName.substring(dotIndex).toLowerCase();
    }
    base = base.toLowerCase();
    base = base.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    base = base.replace(/\s+/g, "-");
    base = base.replace(/[^a-z0-9\-_.]/g, "-");
    return base + extension;
  }
  // Standardizes folder names
  generateStandardNameForFolder(originalName) {
    let base = originalName.toLowerCase();
    base = base.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    base = base.replace(/\s+/g, "-");
    base = base.replace(/[^a-z0-9\-_.]/g, "-");
    return base;
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    this.settings.blacklistedFolders = Array.from(
      new Set(
        (this.settings.blacklistedFolders || []).map((p) => p.trim()).filter((p) => p !== "/" && p !== "")
      )
    );
    this.settings.targetExtensions = Array.from(
      new Set(
        (this.settings.targetExtensions || []).map((e) => e.trim().toLowerCase()).filter(Boolean)
      )
    );
    this.settings.excludedExtensions = Array.from(
      new Set(
        (this.settings.excludedExtensions || []).map((e) => e.trim().toLowerCase()).filter(Boolean)
      )
    );
    this.settings.blacklistedFiles = Array.from(
      new Set(
        (this.settings.blacklistedFiles || []).map((p) => p.trim()).filter(Boolean)
      )
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var VaultFileRenamerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  renderFolderBlacklistList(containerEl) {
    const existing = containerEl.querySelector(".vfr-blacklist-list");
    if (existing)
      existing.remove();
    const list = containerEl.createDiv({ cls: "vfr-blacklist-list" });
    if (this.plugin.settings.blacklistedFolders.length === 0) {
      list.createEl("div", { text: "No folders in the blacklist." });
      return;
    }
    for (const p of this.plugin.settings.blacklistedFolders) {
      const row = list.createDiv({ cls: "vfr-bl-row" });
      row.createEl("code", { text: p });
      const btn = row.createEl("button", { text: "Remove" });
      btn.onclick = async () => {
        this.plugin.settings.blacklistedFolders = this.plugin.settings.blacklistedFolders.filter(
          (x) => x !== p
        );
        await this.plugin.saveSettings();
        this.renderFolderBlacklistList(containerEl);
      };
    }
  }
  renderFileBlacklistList(containerEl) {
    const existing = containerEl.querySelector(".vfr-file-blacklist-list");
    if (existing)
      existing.remove();
    const list = containerEl.createDiv({ cls: "vfr-file-blacklist-list" });
    if (this.plugin.settings.blacklistedFiles.length === 0) {
      list.createEl("div", { text: "No files in the blacklist." });
      return;
    }
    for (const p of this.plugin.settings.blacklistedFiles) {
      const row = list.createDiv({ cls: "vfr-bl-row" });
      row.createEl("code", { text: p });
      const btn = row.createEl("button", { text: "Remove" });
      btn.onclick = async () => {
        this.plugin.settings.blacklistedFiles = this.plugin.settings.blacklistedFiles.filter(
          (x) => x !== p
        );
        await this.plugin.saveSettings();
        this.renderFileBlacklistList(containerEl);
      };
    }
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Vault File Renamer \u2013 Settings" });
    new import_obsidian3.Setting(containerEl).setName("Automatically rename").setDesc(
      "When enabled, files and folders will be standardized on create/rename."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
        this.plugin.settings.enabled = value;
        await this.plugin.saveSettings();
        new import_obsidian3.Notice(
          value ? "Auto-rename enabled." : "Auto-rename disabled."
        );
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Target extensions (allow-list)").setDesc(
      "Which file types to rename. Comma-separated. Example: md, canvas, png. Empty = all."
    ).addText((text) => {
      text.setPlaceholder("md, canvas, png").setValue(this.plugin.settings.targetExtensions.join(", ")).onChange(async (value) => {
        const parts = value.split(",").map((s) => s.trim().toLowerCase()).filter(Boolean);
        this.plugin.settings.targetExtensions = Array.from(
          new Set(parts)
        );
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Excluded extensions (highest priority)").setDesc(
      "These extensions are NEVER renamed. They override the allow-list. Example: tmp, xml"
    ).addText((text) => {
      text.setPlaceholder("tmp, xml").setValue(
        this.plugin.settings.excludedExtensions.join(", ")
      ).onChange(async (value) => {
        const parts = value.split(",").map((s) => s.trim().toLowerCase()).filter(Boolean);
        this.plugin.settings.excludedExtensions = Array.from(
          new Set(parts)
        );
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName("Standardize everything now").setDesc(
      "Run an immediate sweep across the whole vault (respects blacklists/extensions)."
    ).addButton(
      (btn) => btn.setButtonText("Run").onClick(async () => {
        await this.plugin.standardizeAll();
        new import_obsidian3.Notice("Sweep completed.");
      })
    );
    containerEl.createEl("h3", { text: "Folder blacklist" });
    const folderBlock = containerEl.createDiv();
    new import_obsidian3.Setting(folderBlock).setName("Add folder to blacklist").setDesc(
      "Files and subfolders under these paths will NOT be renamed."
    ).addSearch((search) => {
      var _a;
      search.setPlaceholder("e.g., Personal Area/Private").setValue("").onChange((_) => {
      });
      new FolderSuggest(this.app, search.inputEl, async (picked) => {
        const normalized = (0, import_obsidian3.normalizePath)(picked);
        if (!normalized || normalized === "/") {
          new import_obsidian3.Notice("Invalid folder.");
          return;
        }
        if (this.plugin.settings.blacklistedFolders.includes(
          normalized
        )) {
          new import_obsidian3.Notice("This folder is already in the blacklist.");
          return;
        }
        this.plugin.settings.blacklistedFolders.push(normalized);
        await this.plugin.saveSettings();
        this.renderFolderBlacklistList(folderBlock);
        search.setValue("");
        new import_obsidian3.Notice(`Added to blacklist: ${normalized}`);
      });
      const addBtn = createEl("button", { text: "Add" });
      addBtn.style.marginLeft = "8px";
      addBtn.onclick = async () => {
        let raw = search.getValue().trim();
        if (!raw)
          return;
        const normalized = (0, import_obsidian3.normalizePath)(raw);
        if (!normalized || normalized === "/") {
          new import_obsidian3.Notice("Invalid folder.");
          return;
        }
        if (this.plugin.settings.blacklistedFolders.includes(
          normalized
        )) {
          new import_obsidian3.Notice("This folder is already in the blacklist.");
          return;
        }
        this.plugin.settings.blacklistedFolders.push(normalized);
        await this.plugin.saveSettings();
        search.setValue("");
        this.renderFolderBlacklistList(folderBlock);
        new import_obsidian3.Notice(`Added to blacklist: ${normalized}`);
      };
      (_a = search.inputEl.parentElement) == null ? void 0 : _a.appendChild(addBtn);
    });
    this.renderFolderBlacklistList(folderBlock);
    containerEl.createEl("h3", { text: "File blacklist" });
    const fileBlock = containerEl.createDiv();
    new import_obsidian3.Setting(fileBlock).setName("Add file to blacklist").setDesc(
      "These files will NEVER be renamed (exact path match). Useful for files without extension."
    ).addSearch((search) => {
      var _a;
      search.setPlaceholder("e.g., Settings/README or Config").setValue("").onChange((_) => {
      });
      new FileSuggest(this.app, search.inputEl, async (picked) => {
        const normalized = (0, import_obsidian3.normalizePath)(picked);
        if (!normalized) {
          new import_obsidian3.Notice("Invalid file path.");
          return;
        }
        if (this.plugin.settings.blacklistedFiles.includes(
          normalized
        )) {
          new import_obsidian3.Notice("This file is already in the blacklist.");
          return;
        }
        this.plugin.settings.blacklistedFiles.push(normalized);
        await this.plugin.saveSettings();
        this.renderFileBlacklistList(fileBlock);
        search.setValue("");
        new import_obsidian3.Notice(`Added to blacklist: ${normalized}`);
      });
      const addBtn = createEl("button", { text: "Add" });
      addBtn.style.marginLeft = "8px";
      addBtn.onclick = async () => {
        let raw = search.getValue().trim();
        if (!raw)
          return;
        const normalized = (0, import_obsidian3.normalizePath)(raw);
        if (!normalized) {
          new import_obsidian3.Notice("Invalid file path.");
          return;
        }
        if (this.plugin.settings.blacklistedFiles.includes(
          normalized
        )) {
          new import_obsidian3.Notice("This file is already in the blacklist.");
          return;
        }
        this.plugin.settings.blacklistedFiles.push(normalized);
        await this.plugin.saveSettings();
        search.setValue("");
        this.renderFileBlacklistList(fileBlock);
        new import_obsidian3.Notice(`Added to blacklist: ${normalized}`);
      };
      (_a = search.inputEl.parentElement) == null ? void 0 : _a.appendChild(addBtn);
    });
    this.renderFileBlacklistList(fileBlock);
    const tip = containerEl.createEl("p");
    tip.setText(
      "Tip: for safety, the plugin ignores '.obsidian' by default. You may remove it if you wish."
    );
  }
};


/* nosourcemap */